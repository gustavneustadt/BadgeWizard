//
// This View is inspired by the [Flutter App](https://github.com/fossasia/badgemagic-app) from FOSS ASIA and their Badge Preview
//

import SwiftUI
import Combine

struct LEDPreviewView: View {
    @ObservedObject var message: Message
    var pixels: [[Pixel]] {
        message.getCombinedPixelArrays()
    }
    
    var mode: Message.Mode {
        message.mode
    }
    
    var speed: Message.Speed {
        message.speed
    }
    
    var flash: Bool {
        message.flash
    }
    
    var marquee: Bool {
        message.marquee
    }
    
    @State internal var currentPosition: Double = 0
    @State var size: CGSize = .zero
    
    // Display buffer - represents the actual LED state
    @State internal var displayBuffer: [[Bool]] = Array(repeating: Array(repeating: false, count: 44), count: 11)
    @State internal var animationStep: Int = 0
    
    let timer: Publishers.Autoconnect<Timer.TimerPublisher>
    
    internal var speedMultiplier: Double {
        // This numbers were generated by stopping the time of the actual hardware with a stopwatch
        switch speed {
        case .verySlow: return 0.126
        case .slow: return 0.188
        case .relaxed: return 0.257
        case .medium: return 0.329
        case .steady: return 0.466
        case .quick: return 0.797
        case .fast: return 1.125
        case .veryFast: return 2.444
        }
    }
    
    
    private var ledSize: CGFloat {
        size.width / CGFloat(44)
    }
    
    private var ledSpacing: CGFloat {
        ledSize / 4
    }
    
    var body: some View {
        Canvas { context, size in
            // Draw background
            context.fill(
                Path(roundedRect: CGRect(origin: .zero, size: size),
                     cornerRadius: (ledSize / 2) - ledSpacing),
                with: .color(.black)
            )
            let ledPath = Path(ellipseIn: CGRect(origin: .zero, size: .init(width: ledSize-2, height: ledSize-2)))
            
            
            // Draw LED matrix
            for y in 0..<11 {
                for x in 0..<44 {
                    
                    let offset: CGSize = .init(width: CGFloat(x) * (ledSize) + ledSpacing / 2, height: CGFloat(y) * (ledSize) + ledSpacing / 2)
                    
                    context.translateBy(x: offset.width, y: offset.height)
                    if displayBuffer[y][x] {
                        // LED dot (on)
                        context.fill(ledPath, with: .color(.accentColor))
                    } else {
                        // LED dot (off)
                        context.fill(ledPath, with: .color(.accentColor.opacity(0.2)))
                    }
                    context.translateBy(x: -offset.width, y: -offset.height)
                }
            }
        }
        .frame(height: 11 * ledSize)
        // Based on the given width we want to calculate the LED Size and this the height of the badge
        .getSize($size)
        .onReceive(timer) { _ in
            updateAnimation()
        }
    }
    
    private func updateAnimation() {
        // Increment position based on speed
        currentPosition += speedMultiplier
        
        // Create a new buffer for this frame
        var newBuffer = Array(repeating: Array(repeating: false, count: 44), count: 11)
        
        switch mode {
        case .left:
            scrollLeft(&newBuffer)
        case .right:
            scrollRight(&newBuffer)
        case .up:
            scrollUp(&newBuffer)
        case .down:
            scrollDown(&newBuffer)
        case .fixed:
            displayFixed(&newBuffer)
        case .picture:
            displayPicture(&newBuffer)
        case .snowflake:
            displaySnowflake(&newBuffer)
        case .animation:
            displayAnimation(&newBuffer)
        case .laser:
            displayLaser(&newBuffer)
        }
        
        // Store the main content before applying effects
        var contentBuffer = newBuffer
        
        // Apply flash effect to main content if enabled
        if flash && (animationStep % 20) < 10 {
            contentBuffer = Array(repeating: Array(repeating: false, count: 44), count: 11)
        }
        
        // Apply marquee effect if enabled
        if marquee {
            // Start with the flashed or unflashed content
            newBuffer = contentBuffer
            applyMarquee(&newBuffer)
        } else {
            // If no marquee, just use the content with flash applied
            newBuffer = contentBuffer
        }
        
        displayBuffer = newBuffer
        animationStep += 1
    }
}


// #Preview {
//     let timer = Timer.publish(every: 0.05, on: .main, in: .common).autoconnect()
//     
//     LEDPreviewView(
//         pixels: AnimationPatternGenerator.createMovingCircle(),
//         mode: .picture,
//         speed: .veryFast,
//         flash: false,
//         marquee: false,
//         timer: timer
//     )
//     .padding()
//     .background(Color.gray.opacity(0.2))
// }


